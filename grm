#!/bin/sh
# grm: git repo manager for self-hosted git servers

#---------------+----------+-----------------#
#               |  config  |                 #
#               +----------+                 #

# root directory of git repositories
# GRM_REPOS_ROOT="/home/git"

# default owner
# GRM_OWNER="yourname"

# default url prefix (without ending slash)
# GRM_URL_PREFIX="git://git.domain.tld"

# path of the post-receive hooks for stagit
# GRM_POSTRECV_HOOK="/home/git/.post-receive"

# root directory of stagit web pages
# STAGIT_WEB_ROOT="/srv/git"

#                                            #
#                                            #
#--------------------------------------------#

# for stagit
export LC_CTYPE="en_US.UTF-8"

prog_name=$(basename "$0")
repos_root=${GRM_REPOS_ROOT:-/home/git}
web_root=${STAGIT_WEB_ROOT:-/srv/git}

recompile_repo() {
  echo "[$1] recompiling stagit pages..."
  repo_dir="${repos_root}/${1}.git"
  repo_web_dir="${web_root}/${repo_name}"
  cachefile="${repo_dir}/.htmlcache"

  [ -d "$repo_dir" ] || { echo "[$1] repo not found"; return 1; }
  mkdir -p "$repo_web_dir"

  cd "${repo_web_dir:?}"             && \
  rm -f "$cachefile"                 && \
  rm -rf "commit"                    && \
  stagit -c "$cachefile" "$repo_dir" && \
  ln -sf log.html index.html         && \
  echo "[$1] done!"
}

rebuild_index() {
  echo "[index] rebuilding index..."
  mkdir -p "${web_root}" || return 1;
  # 1. find all directories in $repos_root ending with .git
  # 2. filter all the public repos (with git-daemon-export-ok)
  # 3. exclude any repo marked with stagit-no-index
  # 4. sort the result
  # 5. run stagit-index on the result
  # 6. export result to index.html
  find "${repos_root}/." ! -name . -prune     \
    -type d -name "*.git"                     \
    -exec test -e "{}/git-daemon-export-ok" \;\
    -exec test ! -e "{}/stagit-no-index" \;\
    -print |                                  \
    sort -f | xargs stagit-index > "${web_root}/index.html" && \
  echo "[index] done!"
}

grm_new() {
  default_owner=${GRM_OWNER:-$(logname)}
  url_prefix=${GRM_URL_PREFIX:-git://$(hostname)}
  postrecv_path=${GRM_POSTRECV_HOOK:-/usr/local/share/doc/stagit/post-receive}
  default_desc="a work in progress"

  printf "repo name: "
  read -r repo_name
  [ -z "$repo_name" ] && \
    { echo "no repo name given, exiting..."; exit 1; }

  # now we have the complete path of the repo
  repo_path="$repos_root/${repo_name}.git"
  [ -e "$repo_path" ] && \
    { echo "repository already exists"; exit 1; }

  printf "public? [y/N] "
  read -r repo_public

  printf "description (%s): " "$default_desc"
  read -r repo_desc
  repo_desc=${repo_desc:-$default_desc}

  printf "owner (%s): " "$default_owner"
  read -r owner
  owner=${owner:-$default_owner}

  printf "clone url (%s): " "$url_prefix/$repo_name"
  read -r clone_url
  clone_url=${clone_url:-$url_prefix/$repo_name}

  # first, create an empty directory
  mkdir -p "$repo_path"
  cd "$repo_path" || exit 1 # stop if directory can't be created

  # initialize repo
  git init --bare

  # write stagit related metadata
  echo "writing stagit metadata..."
  printf "%s\n" "$repo_desc" > "$repo_path/description"
  printf "%s\n" "$owner" > "$repo_path/owner"
  printf "%s\n" "$clone_url" > "$repo_path/url"

  # export public repository for git daemon
  if echo "$repo_public" | grep -iq "^y$"; then
    echo "exporting repo for git daemon..."
    touch "$repo_path/git-daemon-export-ok"
  fi

  # install post-receive hook from stagit
  echo "installing stagit post-receive hook"
  ln -sf "$postrecv_path" "$repo_path/hooks/post-receive"

  # done
  echo "done!"
}

grm_remove() {
  [ $# -gt 0 ] || { echo "no repo name given, exiting..."; exit 1; }

  for repo in "$@"
  do
    printf "remove %s? [y/N] " "$repo"
    read -r resp
    if echo "$resp" | grep -iq "^y$"; then
      rm -rf "${repos_root:?}/${repo:?}.git" || continue;
      rm -rf "${web_root:?}/${repo:?}" || continue;
    fi
  done
  # only rebuild index if stagit exists
  command -v stagit-index >/dev/null && rebuild_index &
}

grm_list() {
  case "$1" in
    public)
      find "${repos_root}/." ! -name . -prune        \
        -type d -name "*.git"                        \
        -exec test -e "{}/git-daemon-export-ok" \; \
        -exec basename {} '.git' \; ;;
    private)
      find "${repos_root}/." ! -name . -prune        \
        -type d -name "*.git"                        \
        -exec test ! -e "{}/git-daemon-export-ok" \; \
        -exec basename {} '.git' \; ;;
    *)
      find "${repos_root}/." ! -name . -prune \
        -type d -name "*.git"                 \
        -exec basename {} '.git' \; ;;
  esac
}

grm_recompile() {
  for repo_name in "$@"
  do
    recompile_repo "$repo_name" &
  done
  rebuild_index &
  wait
  echo "recompilation done!"
}

grm_recompileall() {
  grm_list public | xargs "$0" rc
}

grm_info() {
  [ -z "$1" ] && { echo "no repo name given, exiting..."; exit 1; }

  repo_name=$1
  repo_dir="${repos_root}/${repo_name}.git"

  [ -d "$repo_dir" ] || { echo "can't find repo named $repo_name"; exit 1; }
  echo "name: $repo_name"

  RED="\033[91m"
  GREEN="\033[92m"
  RESET="\033[0m"

  if [ -e "${repo_dir}/git-daemon-export-ok" ]; then
    printf "%b\n" "visibility: ${GREEN}public${RESET}"
  else
    printf "%b\n" "visibility: ${RED}private${RESET}"
  fi

  [ -f "${repo_dir}/description" ] && \
    echo "description: $(cat "${repo_dir}/description")"

  [ -f "${repo_dir}/owner" ] && \
    echo "owner: $(cat "${repo_dir}/owner")"

  [ -f "${repo_dir}/url" ] && \
    echo "url: $(cat "${repo_dir}/url")"
}

show_help() {
  cat << EOF
usage: $prog_name <command> [<args>]

Git repo manager, manage git repositories on self-hosted git servers.

If you have created a 'git' user for managing git repositories, this
script should be run as:
    $ doas -u git -- $prog_name <command> [<args>]
or
    $ sudo -u git -- $prog_name <command> [<args>]

commands:
    new                  create a new repo
    info repo_name       display metadata of the repo
    ls                   list all repos
    ls public            list public repos
    ls private           list private repos
    rm repo1 [repo2..]   remove repos
    rc                   recompile stagit index
    rc repo1 [repo2..]   recompile stagit pages for repos,
                         and recompile index
    rca                  recompile all public repos
    help                 show help
EOF
}

# parse subcommands
case "$1" in
  new) cmd=new;;
  ls|list) cmd=list;;
  rm|remove) cmd=remove;;
  rc|recompile) cmd=recompile;;
  rca|recompileall) cmd=recompileall;;
  info) cmd=info;;
  *) { show_help; exit; };;
esac

shift
grm_"$cmd" "$@"
